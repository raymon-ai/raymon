---
description: How to use model profiles for data validation.
---

# Validating Data

In this section, we'll use the models and profiles trained in the previous sections to illustrate how to use them for data validation.

## Use case: house prices

### Validating input data

Let's start with the house price prediction model and profile we have built in [the structured data example](building-house-prices.md). From that example, we can take one row from the `X_test` data frame and act like it is a new datum that our production system receives. After loading the model profile, we can use it to validate our input data by calling `profile.validate_input()`

```python
profile = ModelProfile.load("housepricescheap@3.0.0.json")
request = X_test[feature_selector].iloc[0, :]
tags = profile.validate_input(request)
```

This returns tags. Tags are a core concept of raymon, both for the raymon library and on the Raymon platform. A tag has a `name`, `value`, `type` and optionally a `group`. Tags can be used to attach any type of metadata to a [trace](../using-the-raymon-hub/untitled.md). Here, our profile generates a set of tags when validating data. Let's inspect those tags a bit. When viewing the tags variable generated above, we get something like the following:

```javascript
[{'type': 'profile-input',
  'name': 'mssubclass',
  'value': 70,
  'group': 'housepricescheap@3.0.0'},
 {'type': 'profile-input',
  'name': 'lotarea',
  'value': 9550,
  'group': 'housepricescheap@3.0.0'},
 {'type': 'profile-input',
  'name': 'overallqual',
  'value': 7,
  'group': 'housepricescheap@3.0.0'},
 {'type': 'profile-input',
  'name': 'overallcond',
  'value': 5,
  'group': 'housepricescheap@3.0.0'},
 {'type': 'profile-input',
  'name': 'yearbuilt',
  'value': 1915,
  'group': 'housepricescheap@3.0.0'},
 {'type': 'profile-input',
  'name': 'yearremodadd',
  'value': 1970,
  'group': 'housepricescheap@3.0.0'},
  ...
  ]
```

Here, the profile generated a tag for every input component. Every tag is of type `profile-input`, indicating that it is, well, a profile input. All tags also belong to the group `housepricescheap@3.0.0,` indicating that they were generated by this profile. Furthermore, all tags have a `name`, which is the name of the component that generated the tag, and a `value`, which is the value the extractor extracted from the data. Clearly, most tags here are simple the input features of our model.

Let's modify the input a bit by inserting an abnormal feature value and validate it again.

```python
from raymon.tags import filter_errors

invalid = X_test[feature_selector].iloc[0, :].copy()
# Some weird value
invalid['1stFlrSF'] = 10000
tags = profile.validate_input(invalid)
filter_errors(tags)
```

This should output something like this:

```javascript
[{'type': 'profile-input-error',
  'name': 'outlier_score-error',
  'value': 'UpperBoundError',
  'group': 'housepricescheap@3.0.0'},
 {'type': 'profile-input-error',
  'name': '1stflrsf-error',
  'value': 'UpperBoundError',
  'group': 'housepricescheap@3.0.0'}]
```

As you can see, profiles will generate error tags for abnormal or invalid feature values. Invalid values can be values outside of the domain seen during training, or it can be None or NaN values. If you want to be very strict, you could throw an exception every time an error tag is generated. Alternatively, you can use the Raymon platform to tag [prediction traces](../using-the-raymon-hub/untitled.md) with error tags. That way, you can easily find and debug data errors.

### Inspecting the data

We can call `profile.view` to inspect the current datum, and see how it relates to the profile.

```python
from raymon.tags import flatten_jcr

profile.view(poi=tags)
```

This gives the following view. The green lines indicate the position of the POI we are inspecting. As you can see, the `1stFlrSF` feature, is way outside the domain we have seen during training.

![Inspecting a profile with a POI](<../.gitbook/assets/image (8) (1).png>)

### Validating outputs, actuals and evaluations

Of course, we cannot only validate inputs, but use the profiles to validate outputs, actuals and evaluations too.

```python
request_actual = y_test.iloc[0:1, :]
request_pred = rf.predict(coltf.transform(request.to_frame().T))

output_tags = profile.validate_output(request_pred[:, None])
actual_tags = profile.validate_actual(request_actual[:, None])
eval_tags = profile.validate_eval(output=request_pred[:, None], 
                                  actual=request_actual[:, None])
# or all at once:
all_tags = profile.validate_all(input=request, 
                                output=request_pred[:, None], 
                                actual=request_actual[:, None])
```

## Use case: computer vision

Validating data for other data types works similarly. Let's continue on the manufacturing quality inspection case.

```python
profile.validate_input(loaded_data[-1])
```

Will generate tags for the input validation. We can inspect this just like before:

![All is looking good.](<../.gitbook/assets/image (5) (1).png>)

When we distort the image, for example by blurring it, we'll get some errors:

```python
from PIL import ImageFilter

img_blur = loaded_data[-1].copy().filter(ImageFilter.GaussianBlur(radius=5))
img_blur
```

![The image looks like this now. Pretty bad.](<../.gitbook/assets/blur (1).jpg>)

Validating the data gives the errors we expect:

```python
tags_blur = profile.validate_input(img_blur)
tags_blur
```

```javascript
[{'type': 'profile-input',
  'name': 'sharpness',
  'value': 3.024211111111111,
  'group': 'casting-inspection@0.0.1'},
 {'type': 'profile-input-error',
  'name': 'sharpness-error',
  'value': 'LowerBoundError',
  'group': 'casting-inspection@0.0.1'},
 {'type': 'profile-input',
  'name': 'outlierscore',
  'value': 77.50198801658236,
  'group': 'casting-inspection@0.0.1'},
 {'type': 'profile-input-error',
  'name': 'outlierscore-error',
  'value': 'UpperBoundError',
  'group': 'casting-inspection@0.0.1'}]
```

Inspecting the POI in the profile clearly indicates the errors:

```python
profile.view(poi=tags_blur)
```

![](<../.gitbook/assets/image (4) (1).png>)

## Wrapping up

Using profiles you can easily validate new data. You can use the tags to throw exceptions, or send them to any monitoring platform. Additionally, you can use the tags to tag your prediction traces on the Raymon platform.

In the next section, we'll discuss contrasting data profiles to guard against data drift.
